# 함수

코드를 작성하다 보면 유사한 동작을 하는 코드가 계속 쓰이는 경우가 많습니다.

사용자가 로그인이나 로그아웃을 했들 때 동작하는 안내 메세지 같은 경우가 그런 사례입니다.

함수는 프로그램을 구성하는 주요한 '구성요소(building block)'입니다. 함수를 이용하면 유사한 동작을 하는 코드를 계속해서 호출을 할 수 있습니다.

`alert(message)` , `promt(message, default)` , `confirm(question)` 와 같은 내장함수 처럼, 이번 챕터에서는 함수를 직접 만드는 방법에 대해서 알아보록 하겠습니다.  
<br/>
## 함수 선언

함수 선연(function declaration) 방식을 이용하면 함수를 만들 수 있습니다(함수 선언 방식은 선언문이라고 부르기도 합니다.)

함수 선언 방식은 다음과 같이 작성할 수 있습니다.
``` javascript
function sayHello(){
  alert('오하요!');
}
```
`function` 키워드, 함수 이름, 괄호로 둘러싼 매개변수를 차례대로 써주면 함수를 선언할 수 있습니다. 위의 함수는 매개변수가 없는데, 만약 매개변수가 여러 개 있다면 각 매개변수를 콤마로 구분해줍니다. 이어서 함수를 구성하는 코드의 모임인 '함수 본문(body)을 중괄호로 감싸 붙여줍니다.'
```javascript
function name(parameters){
    ...함수 본문...
}
```

새롭게 정의한 함수는 함수 이름 옆에 괄호를 붙여서 호출할 수 있습니다.


예시:

```javascript
function sayHello(){
  alert('오하요!');
}

sayHello();
sayHello();
```

`showMessage()`로 함수를 호출하면 함수 본문이 실행됩니다. 위 예시에선 showMessage를 두 번 호출했으므로 얼럿 창이 두번 뜹니다.

함수의 주요 용도 중 하나는 중복되는 코드를 줄이는 것입니다. 위 예시를 통해 이를 확인해봤습니다.

얼럿창에 보여줄 메세지를 바꾸거나 메세지를 보여주는 방식 자체를 변경하고 싶다면, 함수 본문 중 출력에 관여하는 코드 딱 하나만 수정해주면 됩니다.  
<br/>

## 지역 변수

함수 안에서 선언한 변수인 지역 변수(local variable)은 함수 내에서만 접근 할 수 있습니다.

예시 :

```javascript
function sayHello(){
  let greeting = "오하요!"; // 지역 변수
  
  alert( greeting ); // 오하요!
}

sayHello(); 오하요!

alert( greeting ) // ReferenceError: greeting is not defined (greeting 변수는 sayHello()함수 안에서만 선언 되었지 외부에 선언되어 있지 않기 때문에 자스는 외부에서 사용하면 모르쇠를 시전합니다.)
```  
<br/>

## 외부 변수

함수에선 외부 변수에 접근하는 것뿐만 아니라, 수정도 할 수 있습니다.
예시:

```javascript
let userName ='Ahn';

function sayHello(){
  let greeting = '오하요, ' + userName;
  alert(greeting);
}

sayHello(); // 오하요, Ahn
```

함수에선 외부 변수에 접근하는 것뿐만 아니라, 수정도 할 수 있습니다.

예시:

```javascript
let userName ='Ahn';

function sayHello(){
  userName = "jennie";

  let greeting = '오하요, ' + userName;
  alert(greeting);
}

alert( userName ); // 함수 호출 전에는 Ahn이 출력됩니다.

sayHello();

alert( userName ); // sayHello() 함수에 의해 userName 값은 Jennie로 수정(업데이트)됩니다.
```

외부 변수는 지역 변수가 없는 경우에만 사용할 수 있습니다.

함수 내부에 외부 변수와 동일한 이름을 가진 변수가 선언되었다면, 내부 변수는 외부 변수를 가립니다. 예시를 살펴봅시다. 함수 내부에 외부 변수와 동일한 이름가진지역 변수 `userName`가 선언되어 있습니다. 외부 변수는 내부 변수에 가려져 값이 수정되지 않았습니다.

```javascript
let userName = 'Ahn';

function sayHello(){
  let userName = "Jennie"; // 같은 이름을 가진 지역 변수를 선언합니다.
  
  let message = 'Hello, ' + userName; // Jennie
}

// 함수는 내부 변수인 userName만을 사용합니다.
sayHello();

alert( userName ); // 함수는 외부 변수에 접근하지 않았음으로 값이 변경되지 않고, `Ahn` 이 출력됩니다.
```

> **ⓘ 전역 변수**
>  
> 위 예시의 `userName`처럼, 함수 외부에 선언된 변수는 *전역 변수(global variable)* 이라고 부릅니다.  
> 전역 변수는 같은 이름을 가진 지역 변수에 의해 가려지지만 않는다면 모든 함수에서 접근할 수 있습니다.  
> 변수는 연관되는 함수 내에 선언하고, 전역 변수는 되도록 사용하지 않는 것이 좋습니다. 비교적 근래에 작성된 코드들은 대부분 전역변수를 사용하지 않거나 최소한으로만 사용합니다. 다만 프로젝트 전반에서 사용되는 데이터는 전역 변수에 저장하는 것이 유용한 경우도 있으니 이 점을 알아두시기 바랍니다.  

<br/>

## 매개변수

매개변수(parameter)를 이용하면 임의의 데이터를 함수 안에 전달할 수 있습니다. 매개변수는 인수(argument) 라고 불리기도 합니다(매개변수와 인수는 엄밀히 같진 않지만, 참조한 글에서 듀토리얼 원문을 토대로 번역되어 있습니다.)

아래 예시에서 함수 sayHello는 매개변수 `from` 과 `text` 를 가집니다.

```javascript
function sayHello(from, text) { // 인수: from, text
  alert(from + ': ' + text);
}

sayHello('Son', 'Hello!'); // Son : Hello! (*)
sayHello('Son', "What's up?"); // Son : What's up? (**)
```

`(*)` , `(**)` 로 표시한 줄에서 함수를 호출하면, 함수에 전달된 인자는 지역변수 `from` 과 `text` 에 복사됩니다. 그 후 함수는 지역변수에 복사된 값을 사용합니다.

예시 하나를 더 살펴봅시다. 전역 변수 `from` 이 있고, 이 변수를 함수에 전달하였습니다. 함수가 `from`을 변경하지만, 변경 사항은 외부 변수 `from`에 반영되지 않았습니다. 함수는 언제나 복사된 값을 사용하기 때문입니다.

```javascript
function sayHello(from, text) {
  from = '*' + from + '*'; // "from" 을 좀 더 멋지게 꾸며줍니다.
  
  alert( from + ': ' + text );
}

let from = "Ahn";

sayHello(from, "Hello"); // *Ahn*: Hello

// 함수는 복사된 값을 사용하기 때문에 바깥의 "from" 은 변경 되지 않습니다.
alert( from ); // Ahn
```  

## 기본값

매개변수에 값을 전달하지 않으면 그 값은 `undefined`가 됩니다.

예시를 통해 이에 대해 알아봅시다. 위에서 정의한 함수
`sayHello(from, text)`는 매개변수가 2개지만, 아래와 같이 인수를 하나만 넣어서 호출할 수 있습니다.

```javascript
sayHello("Ahn");
```

이렇게 코드를 작성해도 에러가 발생하지 않습니다. 두 번째 매개변수에 값을 전달하지 않았기 때문에 `text`엔 `undefined` 가 할당될 뿐입니다. 따라서 에러 없이 `"Ahn: undefined"`가 출력됩니다.

매개변수에 값을 전달하지 않아도 그 값이 `undefined`가 되지 않게 하려면 '기본값(default value)`을 설정해주면 됩니다. 매개변수 오른쪽에 `=` 을 붙이고 `undefined` 대신 설정하고자 하는 기본값을 써주면 되죠.

```javascript
function sayHello(from, text = "no text given") {
  alert( from + ": " + text );
}

sayHello("Ahn"); // Ahn: no text given
```

이젠 `text` 가 값을 전달받지 못해도 undefined 대신 기본값 `"no text given"` 이 할당됩니다.

위 예시에선 문자열 `"no text given"` 을 기본값으로 설정했습니다. 하지만 아래와 같이 복잡한 표현식도 기본값으로 설정할 수도 있습니다.

```javascript
function sayHello(from, text = anotherFunction()){
  // anotherFunction()은 text값이 없을 때만 호출됨
  // anotherFunction()의 반환 값이 text의 값이 됨
}
```

> **ⓘ 매개변수 기본값 평가 시점**
> 
> 자바스트립트에선 함수를 호출할 때마다 매개변수 기본값을 평가합니다. 물론 해당하는 매개변수가 없을 때만 기본값을 평가하죠.  
> 위 예시에선 매개변수 `text` 에 값이 없는 경우 `sayHello()` 를 호출할 때마다 `anotherFunction` 이 호출됩니다.

<br/>
### 매개변수 기본값을 설정할 수 있는 또 다른 방법

가끔은 함수 선언부에서 매개변수 기본값을 설정하는 것 대신 함수가 실행되는 도중에 기본값을 설정하는 게 논리에 맞는 경우가 생기기도 합니다.

이런 경우엔 일단 매개변수를 `undefined` 와 비교하여 함수 호출 시 매개변수가 생략되었는지를 확인합니다.

```javascript
function sayHello(text){
  if (text === undefined) {
    text = '빈 문자열';
  }
  
  alert(text);
}

sayHello(); // 빈 문자열
```

이렇게 `if` 문을 쓰는 것 대신 논리 연산자 `||`를 사용할 수 도 있습니다.

```javascript
// 매개변수가 생략되었거나 빈 문자열("")이 넘어오면 변수에 '빈 문자열'이 할당됩니다.
function showMessage(text){
  text = text || '빈 문자열';
  ...
}
```

이 외에도 모던 자바스크립트 엔진이 지원하는 <span style='color: blue'>nullish 병합 연산자(nullish coalescing operator)</span> `??`를 사용하면 `0` 처럼 falsy로 평가되는 값들을 일반 값처럼 처리할 수 있어서 좋습니다.

```javascript
/// 매개변수 'count'가 넘어 오지 않으면 'unknown'을 출력해주는 함수
function showCount(count) {
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
```
<br/>
## 반환 값

함수를 호출했을 떄 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있습니다. 이때 특정 값을 반환 값(return value)이라고 부릅니다.

인수로 받은 두 값을 더해주는 간단한 함수를 만들어 반환 값에 대해 알아보도록 하겠습니다.

```javascript
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

지시자 `return`은 함수 내 어디서든 사용할 수 있습니다. 실행 흐름이 지시자 `return` 을 만나면 함수 실행은 즉시 중단된고 함수를 호출 곳에 값을 반환합니다 위 예시에선 반환 값을 `result`에 할당하였습니다.
아래와 같이 함수 하나에 여러 개의 `return` 문이 올 수도 있습니다.

```javascript
function checkAge(age){
  if (age >= 18){
    return true;
  } else {
    return confirm('보호자의 동의를 받으셨나요?');
  }
}

let age = prompt('나이를 알려주세요' , 18);

if ( checkAge(age) ) {
  alert( '접속 허용' );
} else {
  alert( '접속차단' );
}
```

아래와 같이 지시자 `return` 만 명시하는 것도 가능합니다. 이런 경우는 함수가 즉시 종료됩니다.

```javascript
function showMovie(age) {
  if ( !checkAge(age ) ) {
    return;
  }
  
  alert( "영화 상영" ); // (*)
  // ...
}
```

위 예시에서, checkAge(age) 가 `false` 를 반환하면, `(*)` 로 표시한 줄은 실행이 안 되기 때문에 함수 `showMovie` 는 얼럿 창을 보여주지 않습니다.

>  **ⓘ** `return` **문이 없거나** `return` **지시자만 있는 함수는** `undefined` **를 반환합니다.**
>  
>  `return` 문이 없는 함수도 무언가를 반환합니다. `undefined` 를 반환하죠.
>  ```javascript
>  function doNothing() { /* empty */ }
>
>  alert( doNothing() === undefined ); // true
>  ```
>  
>  `return` 지시자만 있는 경우도 `undefined` 를 반환합니다. `return`  은 `return undefined` 와 동일하게 동작하죠.
>  ```javascript
>  function doNothing(){
>    return;  
>  }
>
>  alert( doNothing() === undefined ); // true
>  ```

> **※** `return` **과 값 사이에 절대 줄을 삽입하지 마세요.**  
> 
> 반환하려는 값이 긴 표현식인 경우, 아래와 같이 지시사 `return` 과 반환하려는 값 사이에 새 줄을 넣어 코드를 작성하고 싶을 수도 있습니다.
> ```javascript
> return
>   (some + long + expression + or + whatever * f(a) + f(b))
> ```
>
> 자바스트립트는 return문 끝에서 세미콜론을 자동으로 넣기 때문에 이렇게 `return`문을 작성하면 안 됩니다. 위 코드는 아래 코드처럼 동작합니다.
>
> ```javascript
> return;
>   (some + long + expression + or + whatever * f(a) + f(b))
> ```
> 
> 따라서 반환하고자 했던 표현식을 반환하지 못하고 아무것도 반환하지 않는 것처럼 되어 버립니다.  
> 표현식을 여러 줄에 걸쳐 작성하고 싶다면 표현식이 `return` 지시자가 있는 줄에서 시작하도록 작성해야 합니다. 또는 아래와 같이 괄호를 `return` 지시자와 같은 줄에 써줘도 괜찮습니다.
> 
> ```javascript
> return (
> some + long + expression
> + or +
> whatever * f(a) + f(b)
>   )
> ```
> 이렇게 하면 의도한 대로 표현식을 반환할 수 있습니다.
