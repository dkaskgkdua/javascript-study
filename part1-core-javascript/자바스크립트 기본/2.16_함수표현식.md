# 함수 표현식

자바스크립트는 함수를 특별한 종류의 값으로 취급한다. 다른 언어에서처럼 "특별한 동작을 하는 구조"로 취급되지 않는다.

**함수 선언 방식 외에 함수 표현식(Function Expression) 을 사용해서 함수를 만들 수 있다.**
```javascript
let greeting = function() {
  alert( "Hello" );
};
```
함수를 생성하고 변수에 값으 할당하는 것처럼 함수가 변수에 할당되었다. 함수가 어떤 방식으로 만들어졌는지에 관계없이 함수는 값이고,
따라서 변수에 할당할 수 있다. 위 코드에선 함수가 변수 `greeting`에 저장된 값이 되었다.

간단히 말해서 "함수를 만들고 그 함수를 변수 `greeting` 에 할당한 것"

함수 값이기 떄문에 `alert`를 이용하여 함수 코드를 출력할 수도 있다.

```java
function greeting(){
  alert("Hello");
}

alert( greeting ); // 함수 코드가 보임
```
자바스크립트에선 괄호가 있어야만 함수가 호출되기 때문에 마지막 줄에서 `greeting` 함수는 실행되지 않는다.
자바스크립트에서 함수느 값이다. 따라서 함수를 값처럼 취급할 수 있다. 위 코드에선 함수 소스코드가 문자형으로 바뀌어 출력된다.

함수는 `greeting()` 처럼 호출할 수 있다는 점 때문에 일반적인 값과는 조금 다르다.
하지만 그 본질을 값이기때문에 값에 할 수 있는 일을 함수에도 적용할 수 있다.
변수를 복사해 다른 변수에 할당하는 것 같은 일 말이다.

```java
function greeting(){    // (1) 함수 생성
  alert("Hello");
}

let func = greeting;    // (2) 함수 복사

func(); // Hello        // (3) 복사한 함수를 실행(정상적으로 실행된다)
greeting(); //Hello     //     본래 함수도 정상적으로 실행

```
위의 예시에서 다음과 같은 일이 일어났다.
* (1) 에서 함수 선언 방식을 이용해 함수를 생성한다. 생성한 함수는 `greeting`이라는 변수에 저장된다.
* (2) 에선 `greeting` 을 새로운 변수 `func`에 복사한다. 이때 `greeting` 다음에 괄호가 없다는 점에 유의.
  괄호가 있었다면 `func = greeting()` 이 되어 `greeting`함수 그 자체가 아닌 **함수 호출 결과(함수의 반환 값)**가
  `func`에 저장되었을 것이다.
* 이젠 `greeting()` 과 `func()` 로 함수를 호출할 수 있다.

함수 `greeting`은 다음과 같이 함수 표현식을 사용해 정의할 수 있다.

```java
let greeting = function(){
  alert("Hello");
};

let func = greeting;
```
동작 결과는 동일하다.

## 콜백 함수
함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 "나중에 호출(called back)"하는 것이 콜백 함수의 개념이다.

```java
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
// question : 질문
// yes : "yes" 라고 답한 경우 실행되는 함수
// no : "no" 답한 경우 실행되는 함수

function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);
```
위의 코드에서 사용자가 "yes"라고 대답한 경우 `showOk`가 콜백이 되고, "no"라고 대답한 경우 `showCancel`가 콜백이 된다.

아래와 같이 함수 표현식을 사용하면 코드 길이가 짧아진다.
```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);

```

`ask(...)`안에 함수가 선언된 것 처럼, 이렇게 이름 없이 선언한 함수를 익명 함수(anonymous function)라고 부른다.
익명 함수는 변수에 할당된 게 아니기 때문에 `ask` 바깥에선 접근할 수 없다.

## 함수 표현식 vs 함수 선언문
함수 표현식과 선언문의 차이점
### 1. 문법
* 함수 선언문: 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재한다.

```
// 함수 선언문
function sum(a, b) {
  return a + b;
}
```

* 함수 표현식: 함수는 표현식이나 구문 구성(syntax construct) 내부에 생성된다.
  아래 예시에선 함수가 할당 연산자 `=`를 이용해 만든 할당 표현식 우측에 생성되었다.
```
// 함수 표현식
let sum = function(a, b) {
  return a + b;
}
```

### 2. '언제' 자바스크립트 엔진이 함수를 생성하는가?
* **함수 표현식은 `실제 실행 흐름이 해당 함수에 도달했을 때` 함수를 생성한다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있다.**
  (위 예시에서, 실행 흐름이 `let sum = function...` 의 우측 함수 표현식에 도달했을 때.)
* **함수 선언문은 함수 선언문이 정의되기 전에도 호출 가능.**
  따라서 전역 함수 선언문은 스크립트의 어디에 있느냐에 상관 없이 어디서든 사용할 수 있다.
  이유: 자바스크립트의 내부 알고리즘 때문. 자바스크립트는 스크립트 실행 전, 준비단계에서 전역에 선언한 함수 선언문을 찾고 해당 함수를 생성한다.
       스크립트가 진짜 실행되기 전 `초기화 단계`에서 함수 선언 방식으로 정의한 함수가 생성되는 것.
       스크립트는 함수 선언문이 모두 처리된 이후에 실행되기때문에, 스크립트 어디서든 함수 선언문으로 선언한 함수에 접근할 수 있는 것이다.
       
### 3. 스코프(유효 범위)
**엄격 모드에서 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만 블록 밖에서는 함수에 접근하지 못한다.**

런타임에 그 값을 알 수 있는 변수 `age`가 있고 이 변수의 값에 따라 함수 `welcome()`을 다르게 정의해야 하며, 함수 `welcome()`은 나중에 호출해야하는 상황을 가정해보자.

* 함수 선언문의 경우: 함수가 선언된 코드 블록 안에서만 유효하기 때문에 이런 에러가 발생합니다.

```
let age = prompt("나이를 알려주세요.", 18);

// 조건에 따라 함수를 선언함
if (age < 18) {

  function welcome() {
    alert("안녕!");
  }

} else {

  function welcome() {
    alert("안녕하세요!");
  }

}

// 함수를 나중에 호출한다.
welcome(); // Error: welcome is not defined

```
* 함수 표현식: `if`문 밖에 선언한 변수 `welcome`에 함수 표현식으로 만든 함수를 할당하여 호출할 수 있다.

```
let age = prompt("나이를 알려주세요.", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("안녕!");
  };

} else {

  welcome = function() {
    alert("안녕하세요!");
  };

}

welcome(); // 제대로 동작한다.
```

## 마무리
* 함수는 값이다. 따라서 함수도 값처럼 할당, 복사, 선언할 수 있다.
* `함수 선언문` 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 된다.
* `함수 표현식` 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재하게 된다.
* 함수 선언문은 코드 블록이 실행되기도 전에 처리된다. 따라서 블록 내 어디서든 활용 가능하다.
* 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 생성된다.

함수를 선언할 때에 함수가 선언되기 전에도 함수를 활용할 수 있는 함수 선언문 방식을 따르는 것이 좋다. 
함수 선언 방식은 코드를 유연하게 구성할 수 있도록 해주고, 가독성도 좋다.

함수 표현식은 함수 선언문을 사용하기 부적절할 때 사용하는 것이 좋다.
  

