## 프라미스 api

`promise` 클래스에는 5가지 정적 메서드가 있습니다. 이번 챕터에선 다섯 메서드의 유스 케이스에 대해서 빠르게 알아보겠습니다.

## Promise.all

여러 개의 프라미스를 동시에 실행시키고 모든 프라미스가 준비될 때까지 기다린다고 해봅시다.
복수의 URL에 동시에 요청을 보내고, 다운로드가 모두 완료된 후에 콘텐츠를 처리할 때 이런 상황이 발생합니다.
`Promise.all`은 이럴 때 사용할 수 있습니다.

문법:

```js
let promise = promise.all([...promise...]);
```

`Promise.all`은 요소 전체가 프라미스인 배열(엄밀히 따지면 이터러블 객체이지만, 대개는 배열임)을 받고 새로운 프라미스를 반환합니다. 

배열 안 프라미스가 모두 처리되면 새로운 프라미스가 이행되는데, 배열 안 프라미스의 결괏값을 담은 배열이 새로운 프라미스의 `result`가 됩니다.

아래 `promise.all`은 3초 후에 처리되고, 반환되는 프라미스의 `result`는 배열 `[1,2,3]`이 됩니다.

```js
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000)), // 3
]).then(alert); // 프라미스 전체가 처리되면 1, 2, 3 이 반환됩ㄴ디ㅏ. 각 프라미스는 배열을 구성하는 요소가 됩니다.
```

배열 `result`의 요소순서는 `promise.all`에 전달되는 프라미스 순서와 상응한다는 점에 주목해 주시기 바랍니다.
`Promise.all`의 첫 번째 프라미스는 가장 늦게 이행되더라도 처리 결과는 배열의 첫 번째 요소에 저장됩니다.

작업해야 할 데이터가 담긴 배열로 매핑하고, 이 배열을 `Promise.all`로 감싸는 트릭은 자주 사용됩니다.

URL이 담긴 배열을 `fetch`를 써서 처리하는 예시를 살펴봅시다.

```js
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// fetch를 사용해 url을 프라미스로 매핑합니다.
let requests = urls.map(url => fetch(url));

// Promise.all은 모든 작업이 이행될 때까지 기다립니다.
Promise.all(requests)
  .then(response => response.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
```

GitHub 유저네임이 담긴 배열을 사용해 사용자 정보를 가져오는 예시를 살펴봅시다(id를 기준으로 장바구니 목록을 불러올때도 같은 로직을 사용할 수 있습니다).

```js
let name = ['iliakan', 'remy', 'jeresig'];

let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

Promise.all(requests)
  .then(response => {
    //모든 응답이 성공적으로 이행되었습니다.
    for(let response of response) {
      alert(`${response.url}: ${response.status}`); // 모든 url의 응답코드가 200입니다.
    }

    return response;
  })
  // 응답 메세지가 담긴 배열을 response.json()로 매핑해, 내용을 읽습니다.
  .then(response => Promise.all(response.map(r => r.json())))
  // JSON 형태의 응답 메세지는 파싱 되어 배열 'users'에 저장됩니다.
  .then(users => users.forEach(user => alert(user.name)));
```

`Promise.all`에 전돨되는 프라미스 중 하나라도 거부되면, `Promise.all`이 반환하는 프라미스는 에러와 함께 바로 거부됩니다.

예시:

```js
Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: 에러 발생!
```

2초 후 두번째 프라미스가 거부되면서 `Promise.all`전체가 거부되고, `.catch`가 실행됩니다. 거부 에러는 `Promise.all` 전체의 결과가 됩니다.

> ⓘ **에러가 발생하면 다른 프라미스는 무시됩니다.**
> 
> 프라미스가 하나라도 거부되면 `Promise.all`은 즉시 거부되고 배열에 저장된 다른 프라미스의 결과는 완전히 잊힙니다. 이행된 프라미스의 결과도 무시되죠.
> `fetch`를 사용해 호출 여러 개를 만들면, 그중 하나가 실패하더라도 호출은 계속 일어납니다. 그렇더라도
> `Promise.all`은 다른 호출을 더는 신경 쓰지 않습니다. 프라미스가 처리되긴 하겠지만 그 결과는 무시됩니ㅏㄷ.
>
>  프라미스에 '취소'라는 개념이 없어서 `Promise.all`도 프라미스를 취소하지 않습니다. <a href="https://ko.javascript.info/fetch-abort">또 다른 챕터</a>에서 배울 `AbortController`를 사용하면 프라미스 취소가 가능하긴 하지만, 프라미스 API는 아닙니다.

> ⓘ `이터러블 객체`**가 아닌 '일반'값도** `Promise.all(iterable)`**에 넘길 수 있습니다.**
> 
> `Promise.all(...)`은 대개 프라미스가 요소인 이터러블 객체(대부분 배열)을 받습니다. 그런데 프라미스가 아닌 객체가 배열을 구성하면, 요소가 '그대로'결과 배열로 전달됩니다.
> 
> 아래 예시의 결과는 `[1, 2, 3]`입니다.
> ```js
> Promise.all([
>   new Promise((resolve, reject) => {
>     setTimeout(() => resolve(1), 1000)
>   ]),
>   2,
>   3
> ]).then(alert); // 1, 2, 3
> ```
> 
> 이미 결과를 알고 있는 값은 `Promise.all`로 그냥 전달하면 됩니다.
