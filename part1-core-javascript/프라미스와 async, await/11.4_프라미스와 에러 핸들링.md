# 프라미스와 에러 핸들링
프라미스가 거부되면 제어 흐름이 제일 가까운 rejection 핸들러로 넘어간다.
그래서 프라미스 체인을 이용하면 에러를 쉽게 처리할 수 있다.

아래는 예시이다.
```js
fetch("https://없는주소") // 에러
  .then(response => response.json())
  .catch(err => console.log(err))
```
위의 예시처럼 하나 혹은 여러 개의 `.then`뒤에 올 수 있다.


또 다른 예시
```js
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error => console.log(error.message));
```
정상적이라면 `.catch`는 절대 트리거 되지 않는다. 하지만 체인 중 하나라도 거부되면 `.catch`에서 에러를 잡게 된다.

### 암시적인 try...catch
프라미스 executor와 프라미스 핸들러 코드 주위엔 암시적인 `try..catch`가 있다.
예외가 발생하면 암시적 `try..catch`에서 예외를 잡고 이를 reject 처럼 다룬다.

예시
```js
new Promise((resolve, reject) => {
  throw new Error("에러 발생!");
}).catch(console.log); // Error: 에러 발생!

// 또 다른 방법
new Promise((resolve, reject) => {
  reject(new Error("에러 발생!"));
}).catch(console.log); // Error: 에러 발생!
```
위의 예시처럼 암시적`try..catch`는 스스로 에러를 잡고, 에러를 거부상태의 프라미스로 변경시킨다.
혹은 `.then`핸들러 안에서 `throw`를 사용해 에러를 던지면, 이 자체가 거부된 프라미스를 의미하게 된다.
