## 오래된 'var'

> ⓘ **오래된 스크립트를 읽은 데 도움을 주는 글입니다.**
> 
> 이번 주제에선 작성된지 오래된 스크립트를 읽는 데 도움을 줄 만한 내용을 다룹니다.
> 새로운 코드를 작성할 때는 이 방법을 쓰시면 안 됩니다.

<a href ="https://ko.javascript.info/variables">변수</a>를 다룬 첫 번째 장에서 변수 선언 방법 세 가지를 배운 바 있습니다.
1. `let`
2. `const`
3. `var`

`var`로 선언한 변수는 `let`으로 선언한 변수와 유사합니다. 대부분의 경우에 `let`을 `var`로, `var`를 `let`으로 바꿔도 큰 문제 없이 동작합니다.

```javascript
var message = "안녕하세요.";
alert(message); // 안녕하세요.
```

하지만 `var`는 초기 자바스크립트 구현 방식 때문에 `let`과 `const`로 선언한 변수와는 다른 방식으로 동작합니다. 근래엔 `var`를 쓰지 않아서 이를 만나는 건 흔치 않은 일이지만, `var`는 오래전 스크립트에서 당신을 기다리고 있는 괴물 같은 존재 입니다.ㅋㅋ
구식 스크립트를 다룰 계획이 없는 개발자라면 이 챕터를 건너뛰거나 학습을 미루려고 할 겁니다.

하지만 그랬다간 이 괴물에게 물릴 수 있습니다. 특히 `var`를 사용하는 오래된 스크립트를 `let`으로 바꿀 때 `var` 에 대해 제데로 알아두어야 합니다. 그렇지 않으면 예상치 못한 에러를 만날 수 있습니다.


### 'var'는 블록 스코프가 없습니다.

`var`로 선언한 변수의 스코프는 함수 스코프이거나 전역 스포크입니다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능합니다.
예시:

```javascript
if (true) {
  var test = true; // 'let' 대신 'var'를 사용했습니다.
}

alert(test); // true(if 문이 끝났어도 변수에 여전히 접근할 수 있음)
```

`var`는 보드 블록을 무시하기 때문에 `test`는 전역 변수가 됩니다. 전역 스코프에서 이 변수에 접근할 수 있죠.
두 번째 행에서 `var test`가 아닌 `let test`를 사용했다면, 변수 `test`는 `if`문 안에서만 접근할 수 있습니다.

```javascript
if (true) {
  let test = true; // 'let'으로 변수를 선언함 
}

alert(test); // Error: test is not defined
```

반복문에서도 유사한 일이 일어납니다. `var`는 블록이나 루프 수준의 스코프를 형성하지 않기 때문입니다.
```javascript
for (var i = 0; i < 10; i++) {
  // ...
}

alert(i); // 10, 반복문이 종료되었지만 'i'는 전역 변수이므로 여전히 접근 가능합니다.
```

코드 블록이 함수 안에 있다면, `var`는 함수 레벨 변수가 됩니다.

```javascript
function sayHi() {
  if (true) {
    var pharse = "Hello";
  }
  
  alert(phrase); // 제데로 출력이 됩니다.
}


sayHi();
alert(phrase); // Error: phrase is not defined
```

위에서 살펴본 바와 같이, `var`는 `if`, `for` 등의 코드 블록을 관통합니다. 아주 오래전의 자바스크립트에선 블록수준 렉시컬 환경이 만들어지지 않았기 때문입니다. `var`는 구식 자바스크립트의 잔재이죠.

### `var`는 재선언을 허용합니다.

만일 중복된 변수이름을 let으로 선언하면 에러가 발생힙니다.

```javascript
let user;
let user; // SyntaxError: 'user' has already been declared 
```

하지만 var와 함께라면 몇번이든지 상관없이 재선언이 가능합니다. 만약 우리가 var로 이미 선언된 변수를 사용한다면, 그냥 무시됩니다.

```javascript
var user = "Pete";

var user = "John"; // 이 'var'는 아무것도 하지 않습니다 (이미 선언 되었음)
// 위 문장은 에러를 발생시키지 않습니다.

alert(user); // John
```

### 선언하기 전 사용할 수 있는 'var'

`var` 선언은 함수가 시작될 때 처리됩니다. 전역에서 선언한 변수라면 스크립트가 시작될 때 처리되죠.

함수 본문내에서 `var`로 선언한 변수는 선언 위치와 상관없이 함수 본문이 시작되는 지점에서 정의됩니다. (단, 변수가 중첩 함수 내에서 정의되지 않아야 이 규칙이 적용됩니다.)

따라서 아래 두 예제는 동일하게 동작합니다.

```javascript
function sayHi() {
  pharse = "Hello";
  
  alert(pharse);
  
  var phrase;
}
sayHi();
```
`var phrase`가 위로 이동한 것처럼 말이죠.
```javascript
function sayHi() {
  var phrase;
  
  pharse = "Hello";
  
  alert(pharse);
}
sayHi();
```
코드 블록은 무시되기 때문에, 아래 코드 역시 동일하게 동작합니다.

```javascript
function sayHi(){
  phrase = "Hello"; // (*)

  if (false) {
    var phrase;
  }
  
  alert(phrase);
}
sayHi();
```

이렇게 변수가 끌어올려 지는 현상을 '호이스팅(hoisting)'이라고 부릅니다. `var`로 선언한 모든 변수는 함수의 최상위로 '끌어 올려지기(hoisted)' 때문입니다(hoist는 끌어올리다 라는 뜻이 있습니다. - 옮긴이).

바로 위 예제에서 `if (false)` 블록 안 코드는 절대 실행되지 않지만, 이는 호이스팅에 전혀 영향을 주지 않습니다. `if` 내부의 `var`는 함수 `sayHi`의 시작 부분에서 처리되므로 `(*)`로 표시한 줄에서 `phrase`는 이미 정의가 된 상태인 것이죠.

**선언은 호이스팅 되지만 할당은 호이스팅 되지 않습니다.**

예시를 통해 살펴봅시다.

```javascript
function sayHi() {
  alert(pharse);
  
  var pharse = "Hello";
 }
 
 sayHi();
```

`var pharse = "Hello"`행에선 두 가지 일이 일어납니다.
1. 변수 선언(`var`);
2. 변수에 값을 할당(`=`);

변수 선언은 함수 실행이 시작될 때 처리되지만(호이스팅) 할당은 호이스팅 되지 않기 때문에 할당 관련 코드에서 처리됩니다. 따라서 위 예제는 아래 코드처럼 동작하게 됩니다.

```javascript
function sayHi() {
  var pharse; // 선언은 함수 시작 시 처리됩니다.
  
  alert(phrase); // unfefined
  
  phrase = "Hello"; // 할당은 실행 흐름이 해당 코드에 도달했을 때 처리됩니다.
}

sayHi();
```

`var phrase = "Hello"`행에선 두가지 일이 일어납니다.

1. 변수 선언(`var`)
2. 변수에 값을 할당(`=`)




