# iterable 객체

반복 가능한 객체는 배열을 일반화한 객체이다.
이터러블 이라는 개념을 사용하면 어떤 객체에든 `for..of` 반복문을 적용할 수 있다.
대표적인 이터러블로 배열과 문자열이 있다.

배열이 아닌 어떤 것들의 컬렉션(목록, 집합 등)을 나타내는 객체에 `for..of`문법을 적용해 컬렉션 순회를 유용하게 해보자.

## Symbol.iterator

직접 이터러블 객체를 만들어 이터러블이라는 개념을 이해해 보자.
`for..of`를 적용하기에 적합해 보이는 배열이 아닌 객체를 만들었다.
예시의 객체 `range`는 숫자 간격을 나타낸다.
```java
let range = {
  from: 1.
  to: 5
};

// 아래와 같이 for..of가 동작할 수 있도록 하는 것이 목표.
// for(let num of range) ... num=1,2,3,4,5
```
`range`를 이터러블로 만들려면 객체에 `Symbol.iteratot`(특수 내장 심볼)라는 메서드를 추가해 아래와 같은 과정을 거쳐야 한다.
1. `for..of`가 시작되자마자 `for..of`는 `Symbol.iteratot`를 호출한다. `Symbol.itetator`는 반드시 이터레이터(메서드 `next`가 있는 객체)를 반환해야 한다.
2. 이후 `for..of`는 반환된 객체(이터레이터)만을 대상으로 동작한다.
3. `for..of`에 다음 값이 필요하면, `for..of`는 이터레이터의 `next()`메서드를 호출한다.
4. `next()`의 반환 값은 `{done: Boolean, value: any}`와 같은 형태여야 한다. `done=ture`는 반복이 종료되었음을 의미한다. `done=false`일땐 `value`에 다음 값이 저장된다.

`range`를 반복 가능한 객체로 만들어주는 코드는 다음과 같다.
```java
let range = {
  from: 1,
  to: 5
};

// 1. for..of 최초 호출 시, Symbol.iterator가 호출된다.
range[Symbol.iterator] = function() {

  // Symbol.iterator는 이터레이터 객체를 반환한다.
  // 2. 이후 for..of는 반환된 이터레이터 객체만을 대상으로 동작하는데, 이때 다음 값도 정해진다.
  return {
    current: this.from,
    last: this.to,

    // 3. for..of 반복문에 의해 반복마다 next()가 호출된다.
    next() {
      // 4. next()는 값을 객체 {done:.., value :...}형태로 반환해야 한다.
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 이제 의도한 대로 동작한다.
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

이터러블 객체의 핵심은 '관심사의 분리(Separation of concern, SoC)'에 있다.
- `range`엔 메서드 `next()`가 없다.
- 대신 `range[Symbol.iterator]()`를 호출해서 만든 '이터레이터' 객체와 이 객체의 메서드 `next()`에서 반복에 사용될 값을 만들어낸다.

이렇게 하면 이터레이터 객체와 반복 대상인 객체를 분리할 수 있다.
이터레이터 객체와 반복 대상 객체를 합쳐서 `range` 자체를 이터레이터로 만들면 코드가 더 간단해진다.

```java
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```
이제 `range[Symbol.iterator]()`가 객체 `range` 자체를 반환한다. 반환된 객체엔 필수 메서드인 `next()`가 있고 `this.current`에 반복이 얼마나 진행되었는지를 나타내는 값도 저장되어 있다.
코드는 더 짧아졌다. 이렇게 작성하는 것이 좋을 때가 종종 있다.

단점은 두 개의 `for..of`반복문을 하나의 객체에 동시에 사용할 수 없다는 점이다. 이터레이터(객체 자신)가 하나뿐이어서 두 반복문이 반복 상태를 공유하기 때문이다.
그런데 동시에 두 개의 `for..of`를 사용하는 것은 비동기 처리에서도 흔한 케이스는 아니다.

### 무한개의 이터레이터

무수히 많은 이터레이터도 가능하다. `range`에서 `range.to`에 `Infinity`를 할당하면 `range`가 무한대가 된다.
